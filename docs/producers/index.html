<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Producers · FS2 Kafka</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Producers support publishing of records. Producers make use of the [Java Kafka producer][java-kafka-producer], which becomes especially important for [settings](#settings)."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Producers · FS2 Kafka"/><meta property="og:type" content="website"/><meta property="og:url" content="https://fd4s.github.io/fs2-kafka/fs2-kafka/"/><meta property="og:description" content="Producers support publishing of records. Producers make use of the [Java Kafka producer][java-kafka-producer], which becomes especially important for [settings](#settings)."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/fs2-kafka/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/fs2-kafka/js/scrollSpy.js"></script><link rel="stylesheet" href="/fs2-kafka/css/main.css"/><script src="/fs2-kafka/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fs2-kafka/"><img class="logo" src="/fs2-kafka/img/fs2-kafka.white.svg" alt="FS2 Kafka"/><h2 class="headerTitleWithLogo">FS2 Kafka</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/fs2-kafka/api/fs2/kafka/index.html" target="_self">API Docs</a></li><li class="siteNavGroupActive"><a href="/fs2-kafka/docs/overview" target="_self">Documentation</a></li><li class=""><a href="https://github.com/fd4s/fs2-kafka" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Documentation</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/quick-example">Quick Example</a></li><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/consumers">Consumers</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/fs2-kafka/docs/producers">Producers</a></li><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/transactions">Transactions</a></li><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/admin">Admin</a></li><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/modules">Modules</a></li><li class="navListItem"><a class="navItem" href="/fs2-kafka/docs/technical-details">Technical Details</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Producers</h1></header><article><div><span><p>Producers support publishing of records. Producers make use of the <a href="https://kafka.apache.org/24/javadoc/?org/apache/kafka/clients/producer/KafkaProducer.html">Java Kafka producer</a>, which becomes especially important for <a href="#settings">settings</a>.</p>
<p>The following imports are assumed throughout this page.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> cats.effect._
<span class="hljs-keyword">import</span> cats.implicits._
<span class="hljs-keyword">import</span> fs2.kafka._
<span class="hljs-keyword">import</span> scala.concurrent.duration._
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="serializers"></a><a href="#serializers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Serializers</h2>
<p><a href="/fs2-kafka/api/fs2/kafka/Serializer.html"><code>Serializer</code></a> describes functional composable serializers for record keys and values. We generally require two serializers: one for the record key and one for the record value. Serializers are provided implicitly for many standard library types, including:</p>
<ul>
<li><code>Array[Byte]</code>, <code>Double</code>, <code>Float</code>, <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>String</code>, and <code>UUID</code>.</li>
</ul>
<p>There are also serializers for types which carry special meaning:</p>
<ul>
<li><p><code>Option[A]</code> to serialize occurrances of <code>None</code> as <code>null</code>, and</p></li>
<li><p><code>Unit</code> to ignore the value and always serialize as <code>null</code>.</p></li>
</ul>
<p>For more involved types, we need to resort to custom serializers.</p>
<h3><a class="anchor" aria-hidden="true" id="custom-serializers"></a><a href="#custom-serializers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Serializers</h3>
<p><code>Serializer[F[_], A]</code> describes a function <code>A =&gt; F[Array[Byte]]</code>, while also having access to the topic name and record <a href="/fs2-kafka/api/fs2/kafka/Headers.html"><code>Headers</code></a>. There are many <a href="/fs2-kafka/api/fs2/kafka/Serializer$.html">functions</a> available for creating custom serializers, with the most basic one being <code>instance</code>, which simply creates a serializer from a provided function.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Serializer</span>.instance[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>] {
  (topic, headers, s) =&gt;
    <span class="hljs-type">IO</span>.pure(s.getBytes(<span class="hljs-string">"UTF-8"</span>))
}
</code></pre>
<p>If the serializer only needs access to the bytes, like in the case above, use <code>lift</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Serializer</span>.lift[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>](s =&gt; <span class="hljs-type">IO</span>.pure(s.getBytes(<span class="hljs-string">"UTF-8"</span>)))
</code></pre>
<p>To support different serializers for different topics, use <code>topic</code> to pattern match on the topic name.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Serializer</span>.topic[<span class="hljs-type">IO</span>, <span class="hljs-type">Int</span>] {
  <span class="hljs-keyword">case</span> <span class="hljs-string">"first"</span>  =&gt; <span class="hljs-type">Serializer</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>].contramap(_.show)
  <span class="hljs-keyword">case</span> <span class="hljs-string">"second"</span> =&gt; <span class="hljs-type">Serializer</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">Int</span>]
}
</code></pre>
<p>For unmatched topics, an <a href="/fs2-kafka/api/fs2/kafka/UnexpectedTopicException.html"><code>UnexpectedTopicException</code></a> is raised.</p>
<p>Use <code>headers</code> for different deserializers depending on record headers.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Serializer</span>.headers[<span class="hljs-type">IO</span>, <span class="hljs-type">Int</span>] { headers =&gt;
  headers(<span class="hljs-string">"format"</span>).map(_.as[<span class="hljs-type">String</span>]) <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(<span class="hljs-string">"string"</span>) =&gt; <span class="hljs-type">Serializer</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>].contramap(_.show)
    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(<span class="hljs-string">"int"</span>)    =&gt; <span class="hljs-type">Serializer</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">Int</span>]
    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(format)   =&gt; <span class="hljs-type">Serializer</span>.failWith(<span class="hljs-string">s"unknown format: <span class="hljs-subst">$format</span>"</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-type">None</span>           =&gt; <span class="hljs-type">Serializer</span>.failWith(<span class="hljs-string">"format header is missing"</span>)
  }
}
</code></pre>
<p>In the example above, <code>failWith</code> raises a <a href="/fs2-kafka/api/fs2/kafka/SerializationException.html"><code>SerializationException</code></a> with the provided message.</p>
<h3><a class="anchor" aria-hidden="true" id="java-interoperability"></a><a href="#java-interoperability" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Java Interoperability</h3>
<p>If we have a Java Kafka serializer, use <code>delegate</code> to create a <code>Serializer</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Serializer</span>.delegate[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>] {
  <span class="hljs-keyword">new</span> <span class="hljs-type">KafkaSerializer</span>[<span class="hljs-type">String</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span></span>(topic: <span class="hljs-type">String</span>, value: <span class="hljs-type">String</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>] =
      value.getBytes(<span class="hljs-string">"UTF-8"</span>)
  }
}
</code></pre>
<p>If the serializer performs <em>side effects</em>, follow with <code>suspend</code> to capture them properly.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Serializer</span>.delegate[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>] {
   <span class="hljs-keyword">new</span> <span class="hljs-type">KafkaSerializer</span>[<span class="hljs-type">String</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span></span>(topic: <span class="hljs-type">String</span>, value: <span class="hljs-type">String</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>] = {
      println(<span class="hljs-string">s"serializing record on topic <span class="hljs-subst">$topic</span>"</span>)
      value.getBytes(<span class="hljs-string">"UTF-8"</span>)
    }
  }
}.suspend
</code></pre>
<p>Note that <code>close</code> and <code>configure</code> won't be called for the delegates.</p>
<h2><a class="anchor" aria-hidden="true" id="settings"></a><a href="#settings" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Settings</h2>
<p>In order to create a <a href="/fs2-kafka/api/fs2/kafka/KafkaProducer.html"><code>KafkaProducer</code></a>, we first need to create <a href="/fs2-kafka/api/fs2/kafka/ProducerSettings.html"><code>ProducerSettings</code></a>. At the very minimum, settings include the effect type to use, and the key and value serializers. More generally, <a href="/fs2-kafka/api/fs2/kafka/ProducerSettings.html"><code>ProducerSettings</code></a> contain everything necessary to create a <a href="/fs2-kafka/api/fs2/kafka/KafkaProducer.html"><code>KafkaProducer</code></a>. If serializers are available implicitly for the key and value type, we can use the syntax in the following example.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> producerSettings =
  <span class="hljs-type">ProducerSettings</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>, <span class="hljs-type">String</span>]
    .withBootstrapServers(<span class="hljs-string">"localhost"</span>)
</code></pre>
<p>We can also specify the serializers explicitly when necessary.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">ProducerSettings</span>(
  keySerializer = <span class="hljs-type">Serializer</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>],
  valueSerializer = <span class="hljs-type">Serializer</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>]
).withBootstrapServers(<span class="hljs-string">"localhost"</span>)
</code></pre>
<p><a href="/fs2-kafka/api/fs2/kafka/ProducerSettings.html"><code>ProducerSettings</code></a> provides functions for configuring both the Java Kafka producer and options specific to the library. If functions for configuring certain properties of the Java Kafka producer is missing, we can instead use <code>withProperty</code> or <code>withProperties</code> together with constants from <a href="https://kafka.apache.org/24/javadoc/?org/apache/kafka/clients/producer/ProducerConfig.html"><code>ProducerConfig</code></a>. Available properties for the Java Kafka producer are described in the <a href="http://kafka.apache.org/documentation/#producerconfigs">documentation</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="default-settings"></a><a href="#default-settings" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default Settings</h3>
<p>The following Java Kafka producer properties are overridden by default.</p>
<ul>
<li><code>max.retries</code> is set to <code>0</code>, to avoid the risk of records being produced out-of-order. If we don't need to produce records in-order, then this can be set to some positive integer value. An alternative is to enable retries and use <code>withMaxInFlightRequestsPerConnection(1)</code> or <code>withEnableIdempotence(true)</code>. The blog post <a href="https://blog.softwaremill.com/does-kafka-really-guarantee-the-order-of-messages-3ca849fd19d2">Does Kafka really guarantee the order of messages?</a> provides more detail on this topic.</li>
</ul>
<p>The following settings are specific to the library.</p>
<ul>
<li><p><code>withCloseTimeout</code> controls the timeout when waiting for producer shutdown. Default is 60 seconds.</p></li>
<li><p><code>withParallelism</code> sets the max number of <code>ProducerRecords</code> to produce in the same batch when using the <code>produce</code> pipe. Default is 100.</p></li>
<li><p><code>withCreateProducer</code> changes how the underlying Java Kafka producer is created. The default merely creates a Java <code>KafkaProducer</code> instance using set properties, but this function allows overriding the behaviour for e.g. testing purposes.</p></li>
<li><p><code>withBlocker</code> sets the <code>Blocker</code> on which blocking Java Kafka producer functions are executed. Unless specified, a default fixed single-thread pool is created as part of producer initialization, with the thread name using the <code>fs2-kafka-producer</code> prefix.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="producer-creation"></a><a href="#producer-creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Producer Creation</h2>
<p>Once <a href="/fs2-kafka/api/fs2/kafka/ProducerSettings.html"><code>ProducerSettings</code></a> is defined, use <code>producerStream</code> to create a <a href="/fs2-kafka/api/fs2/kafka/KafkaProducer.html"><code>KafkaProducer</code></a> instance.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ProducerExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOApp</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">ExitCode</span>] = {
    <span class="hljs-keyword">val</span> stream =
      producerStream(producerSettings)

    stream.compile.drain.as(<span class="hljs-type">ExitCode</span>.<span class="hljs-type">Success</span>)
  }
}
</code></pre>
<p>There is also <code>producerResource</code> for when it's preferable to work with <code>Resource</code>. Both these functions create an underlying Java Kafka producer. They both also guarantee resource cleanup, i.e. closing the Kafka producer instance.</p>
<p>In the example above, we simply create the producer and then immediately shutdown after resource cleanup. <a href="/fs2-kafka/api/fs2/kafka/KafkaProducer.html"><code>KafkaProducer</code></a> only supports producing records, and there is a separate producer available to support <a href="/fs2-kafka/docs/transactions">transactions</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="producing-records"></a><a href="#producing-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Producing Records</h2>
<p>If we're only producing records in one part of our stream, using <code>produce</code> is convenient.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> consumerSettings =
  <span class="hljs-type">ConsumerSettings</span>[<span class="hljs-type">IO</span>, <span class="hljs-type">String</span>, <span class="hljs-type">String</span>]
    .withAutoOffsetReset(<span class="hljs-type">AutoOffsetReset</span>.<span class="hljs-type">Earliest</span>)
    .withBootstrapServers(<span class="hljs-string">"localhost"</span>)
    .withGroupId(<span class="hljs-string">"group"</span>)

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ProduceExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOApp</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">ExitCode</span>] = {
    <span class="hljs-keyword">val</span> stream =
      consumerStream[<span class="hljs-type">IO</span>]
        .using(consumerSettings)
        .evalTap(_.subscribeTo(<span class="hljs-string">"topic"</span>))
        .flatMap(_.stream)
        .map { committable =&gt;
          <span class="hljs-keyword">val</span> key = committable.record.key
          <span class="hljs-keyword">val</span> value = committable.record.value
          <span class="hljs-keyword">val</span> record = <span class="hljs-type">ProducerRecord</span>(<span class="hljs-string">"topic"</span>, key, value)
          <span class="hljs-type">ProducerRecords</span>.one(record, committable.offset)
        }
        .through(produce(producerSettings))

    stream.compile.drain.as(<span class="hljs-type">ExitCode</span>.<span class="hljs-type">Success</span>)
  }
}
</code></pre>
<p>In the stream above, we're simply producing the records we receive back to the topic.</p>
<p>The <code>produce</code> function creates a <code>KafkaProducer</code> and produces records in <code>ProducerRecords</code>. Note that <code>ProducerRecords</code> support multiple records and a passthrough value, <code>committable.offset</code>. Once all records have been produced in the <code>ProducerRecords</code>, the passthrough will be emitted.</p>
<p>If we're producing in multiple places in our stream, we can create the <code>KafkaProducer</code> ourselves, and pass it to the <code>produce</code> function. Every <code>produce</code> allow up to <code>ProducerSettings#parallelism</code> instances of <code>ProducerRecords</code> to be batched together in the same batch.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">PartitionedProduceExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOApp</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">ExitCode</span>] = {
    <span class="hljs-keyword">val</span> stream =
      producerStream[<span class="hljs-type">IO</span>]
        .using(producerSettings)
        .flatMap { producer =&gt;
          consumerStream[<span class="hljs-type">IO</span>]
            .using(consumerSettings)
            .evalTap(_.subscribeTo(<span class="hljs-string">"topic"</span>))
            .flatMap(_.partitionedStream)
            .map { partition =&gt;
              partition
                .map { committable =&gt;
                  <span class="hljs-keyword">val</span> key = committable.record.key
                  <span class="hljs-keyword">val</span> value = committable.record.value
                  <span class="hljs-keyword">val</span> record = <span class="hljs-type">ProducerRecord</span>(<span class="hljs-string">"topic"</span>, key, value)
                  <span class="hljs-type">ProducerRecords</span>.one(record, committable.offset)
                }
                .through(produce(producerSettings, producer))
            }
            .parJoinUnbounded
        }

    stream.compile.drain.as(<span class="hljs-type">ExitCode</span>.<span class="hljs-type">Success</span>)
  }
}
</code></pre>
<p>If we need more control of how records are produced, we can use <code>KafkaProducer#produce</code>. The function returns two effects, e.g. <code>IO[IO[...]]</code>, where the first effect puts the records in the producer's buffer, and the second effects waits for the records to have been sent.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">KafkaProducerProduceExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOApp</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">ExitCode</span>] = {
    <span class="hljs-keyword">val</span> stream =
      producerStream[<span class="hljs-type">IO</span>]
        .using(producerSettings)
        .flatMap { producer =&gt;
          consumerStream[<span class="hljs-type">IO</span>]
            .using(consumerSettings)
            .evalTap(_.subscribeTo(<span class="hljs-string">"topic"</span>))
            .flatMap(_.stream)
            .map { committable =&gt;
              <span class="hljs-keyword">val</span> key = committable.record.key
              <span class="hljs-keyword">val</span> value = committable.record.value
              <span class="hljs-keyword">val</span> record = <span class="hljs-type">ProducerRecord</span>(<span class="hljs-string">"topic"</span>, key, value)
              <span class="hljs-type">ProducerRecords</span>.one(record, committable.offset)
            }
            .evalMap(producer.produce)
            .groupWithin(<span class="hljs-number">500</span>, <span class="hljs-number">15.</span>seconds)
            .evalMap(_.sequence)
        }


    stream.compile.drain.as(<span class="hljs-type">ExitCode</span>.<span class="hljs-type">Success</span>)
  }
}
</code></pre>
<p>The example above puts 500 records in the producer's buffer or however many can be put in the buffer every 15 seconds, and then waits for those records to finish sending before continuing. Using <code>produce</code> allows more precise control of how records are put in the buffer and when we wait for records to send.</p>
<p>Sometimes there is a need to wait for individual <code>ProducerRecords</code> to send. In this case, we can <code>flatten</code> the result of <code>produce</code> to both send the record and wait for the send to complete. Note that this should generally be avoided, as it achieves poor performance.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">KafkaProducerProduceFlattenExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IOApp</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">ExitCode</span>] = {
    <span class="hljs-keyword">val</span> stream =
      producerStream[<span class="hljs-type">IO</span>]
        .using(producerSettings)
        .flatMap { producer =&gt;
          consumerStream[<span class="hljs-type">IO</span>]
            .using(consumerSettings)
            .evalTap(_.subscribeTo(<span class="hljs-string">"topic"</span>))
            .flatMap(_.stream)
            .map { committable =&gt;
              <span class="hljs-keyword">val</span> key = committable.record.key
              <span class="hljs-keyword">val</span> value = committable.record.value
              <span class="hljs-keyword">val</span> record = <span class="hljs-type">ProducerRecord</span>(<span class="hljs-string">"topic"</span>, key, value)
              <span class="hljs-type">ProducerRecords</span>.one(record, committable.offset)
            }
            .evalMap { record =&gt;
              producer.produce(record).flatten
            }
        }


    stream.compile.drain.as(<span class="hljs-type">ExitCode</span>.<span class="hljs-type">Success</span>)
  }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/fs2-kafka/docs/consumers"><span class="arrow-prev">← </span><span>Consumers</span></a><a class="docs-next button" href="/fs2-kafka/docs/transactions"><span>Transactions</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#serializers">Serializers</a><ul class="toc-headings"><li><a href="#custom-serializers">Custom Serializers</a></li><li><a href="#java-interoperability">Java Interoperability</a></li></ul></li><li><a href="#settings">Settings</a><ul class="toc-headings"><li><a href="#default-settings">Default Settings</a></li></ul></li><li><a href="#producer-creation">Producer Creation</a></li><li><a href="#producing-records">Producing Records</a></li></ul></nav></div><footer class="nav-footer" id="footer"><hr class="separator"/><section class="copyright">Copyright © 2018-2020 OVO Energy Limited.<br/>Icon by <a href="https://www.flaticon.com/authors/franco-averta" rel="noopener">Franco Averta</a>. <a href="https://creativecommons.org/licenses/by/3.0" rel="noopener">CC BY 3.0</a>.</section></footer></div></body></html>